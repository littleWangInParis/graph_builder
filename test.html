<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>D3 Histogram 示例</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <style>
    .bar {
      fill: steelblue;
    }
    .axis text {
      font-size: 12px;
    }
    .axis path,
    .axis line {
      stroke: #333;
    }
  </style>
</head>
<body>
  <svg id="histogram"></svg>

  <script>
    // 1. 准备数据 & 容器
const data = d3.range(1000).map(d3.randomNormal(50, 15));
const margin = { top: 20, right: 20, bottom: 30, left: 40 };
const width = 800 - margin.left - margin.right;
const height = 400 - margin.top - margin.bottom;

const svg = d3.select('svg')
  .attr('width', width + margin.left + margin.right)
  .attr('height', height + margin.top + margin.bottom);

const g = svg.append('g')
  .attr('transform', `translate(${margin.left},${margin.top})`);

// 2. 构造直方图数据
const x = d3.scaleLinear()
  .domain(d3.extent(data)).nice()
  .range([0, width]);

const bins = d3.bin()
  .domain(x.domain())
  .thresholds(x.ticks(30))
  (data);

const y = d3.scaleLinear()
  .domain([0, d3.max(bins, d => d.length)]).nice()
  .range([height, 0]);

// 3. 画坐标轴
g.append('g')
  .attr('transform', `translate(0,${height})`)
  .call(d3.axisBottom(x));

g.append('g')
  .call(d3.axisLeft(y));

// 4. 画柱子：每个 bin 包含两个 rect——base 和 highlight
const bar = g.selectAll('.bar')
  .data(bins)
  .join('g')
    .attr('class', 'bar')
    .attr('transform', d => `translate(${x(d.x0)},${y(d.length)})`);

const barWidth = d => x(d.x1) - x(d.x0);

// 底层柱子
bar.append('rect')
  .attr('width', d => barWidth(d))
  .attr('height', d => height - y(d.length))
  .attr('fill', '#ccc');

// 叠加的高亮柱子，初始宽度为 0
bar.append('rect')
  .attr('class', 'highlight')
  .attr('width', 0)
  .attr('height', d => height - y(d.length))
  .attr('fill', '#ff7f0e');

// 5. 添加横向 brush
const brush = d3.brushX()
  .extent([[0, 0], [width, height]])
  .on('brush end', brushed);

g.append('g')
  .attr('class', 'brush')
  .call(brush);

// 6. brush 事件处理：计算每根柱子与刷选区的重叠部分，更新 highlight rect
function brushed({ selection }) {
  if (!selection) {
    // 清除高亮
    g.selectAll('.highlight')
      .attr('x', 0)
      .attr('width', 0);
    return;
  }

  // 把 pixel 转为数据域
  const [x0, x1] = selection.map(x.invert);

  bar.each(function(d) {
    // 重叠区间：[max(d.x0, x0), min(d.x1, x1)]
    const overlapStart = Math.max(d.x0, x0);
    const overlapEnd   = Math.min(d.x1, x1);
    const overlap = Math.max(0, overlapEnd - overlapStart);

    // 对应到像素
    const px0 = x(overlapStart) - x(d.x0);
    const pw = x(overlapEnd) - x(overlapStart);

    d3.select(this).select('.highlight')
      .attr('x', overlap > 0 ? px0 : 0)
      .attr('width', overlap > 0 ? pw : 0);
  });
}
  </script>
</body>
</html>